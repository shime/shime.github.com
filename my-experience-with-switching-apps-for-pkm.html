<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="//gmpg.org/xfn/11" rel="profile">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/monokai.css?1613935457731556000">
  <link rel="stylesheet" href="/public/css/style.css?1613935457731556000">

  <link rel="icon" sizes="16x16 32x32 64x64" href="/public/favicon.ico">
<link rel="icon" type="image/png" sizes="196x196" href="/public/favicon-196.png">
<link rel="icon" type="image/png" sizes="160x160" href="/public/favicon-160.png">
<link rel="icon" type="image/png" sizes="128x128" href="/public/favicon-128.png">
<link rel="icon" type="image/png" sizes="96x96" href="/public/favicon-96.png">
<link rel="icon" type="image/png" sizes="64x64" href="/public/favicon-64.png">
<link rel="icon" type="image/png" sizes="32x32" href="/public/favicon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/public/favicon-16.png">
<link rel="apple-touch-icon" href="/public/favicon-57.png">
<link rel="apple-touch-icon" sizes="180x180" href="/public/favicon-180.png">
<link rel="apple-touch-icon" sizes="152x152" href="/public/favicon-152.png">
<link rel="apple-touch-icon" sizes="144x144" href="/public/favicon-144.png">
<link rel="apple-touch-icon" sizes="120x120" href="/public/favicon-120.png">
<link rel="apple-touch-icon" sizes="114x114" href="/public/favicon-114.png">
<link rel="apple-touch-icon" sizes="76x76" href="/public/favicon-76.png">
<link rel="apple-touch-icon" sizes="72x72" href="/public/favicon-72.png">
<link rel="apple-touch-icon" sizes="60x60" href="/public/favicon-60.png">
<meta name="msapplication-TileColor" content="#FFFFFF">
<meta name="msapplication-TileImage" content="/public/favicon-144.png">
<meta name="msapplication-config" content="/public/browserconfig.xml">


  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

  <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="My experience with switching apps for personal knowledge management" />
<meta name="author" content="Hrvoje Šimić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Personal knowledge management (PKM) is the best thing I discovered in 2019. I&#39;ve since tried a couple of different approaches and too many (six) apps. In this article, I would like to share everything I&#39;ve learned about it over that period." />
<meta property="og:description" content="Personal knowledge management (PKM) is the best thing I discovered in 2019. I&#39;ve since tried a couple of different approaches and too many (six) apps. In this article, I would like to share everything I&#39;ve learned about it over that period." />
<link rel="canonical" href="http://localhost:4000/my-experience-with-switching-apps-for-pkm" />
<meta property="og:url" content="http://localhost:4000/my-experience-with-switching-apps-for-pkm" />
<meta property="og:site_name" content="Hrvoje Šimić" />
<meta property="og:image" content="http://localhost:4000/public/social.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-13T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="http://localhost:4000/public/social.png" />
<meta property="twitter:title" content="My experience with switching apps for personal knowledge management" />
<meta name="twitter:site" content="@shime_sh" />
<meta name="twitter:creator" content="@shime_sh" />
<script type="application/ld+json">
{"url":"http://localhost:4000/my-experience-with-switching-apps-for-pkm","image":"http://localhost:4000/public/social.png","headline":"My experience with switching apps for personal knowledge management","dateModified":"2020-12-13T00:00:00+01:00","datePublished":"2020-12-13T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/my-experience-with-switching-apps-for-pkm"},"description":"Personal knowledge management (PKM) is the best thing I discovered in 2019. I&#39;ve since tried a couple of different approaches and too many (six) apps. In this article, I would like to share everything I&#39;ve learned about it over that period.","author":{"@type":"Person","name":"Hrvoje Šimić"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  
    <title> My experience with switching apps for personal knowledge management &middot; Hrvoje Šimić </title>
  

  <meta name="title" content="My experience with switching apps for personal knowledge management &middot; Hrvoje Šimić">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
  <script src="https://unpkg.com/time-ago@0.2.1/timeago.js"></script>
  <script src="https://unpkg.com/fetch-polyfill@0.8.2/fetch.js"></script>

  
</head>


  <body class="font-sans">
    <div class="lg:pt-16 lg:pb-16 p-6 relative">
      




<div class="relative flex justify-between items-start w-full z-20 md:justify-center self-center">
  <div class="flex items-center">
    <div class="flex flex-col">
      <a class="text-black font-bold text-xl no-underline font-extrabold self-start" href="/">Hrvoje Šimić</a>
      <a class="text-black font-bold no-underline font-extrabold my-1 self-start" href="https://twitter.com/shime_sh">@shime_sh</a>
      <ul class="hidden md:block list-reset tracking-wide">
        
        <li class="inline">
          
          <a class="font-medium text-xs text-grey no-underline uppercase mr-2 hover:text-black" href='/articles/'>Articles</a>
          
        </li>
        
        <li class="inline">
          
          <a class="font-medium text-xs text-grey no-underline uppercase mr-2 hover:text-black" href='/til/'>TIL</a>
          
        </li>
        
        <li class="inline">
          
          <a class="font-medium text-xs text-grey no-underline uppercase mr-2 hover:text-black" href='/photography/'>Photography</a>
          
        </li>
        
        <li class="inline">
          
          <a class="font-medium text-xs text-grey no-underline uppercase mr-2 hover:text-black" href='/reading/'>Reading list</a>
          
        </li>
        
        <li class="inline">
          
          <a class="font-medium text-xs text-grey no-underline uppercase mr-2 hover:text-black" href='/subscribe'>Subscribe</a>
          
        </li>
        
      </ul>
    </div>
  </div>

  <div class="block md:hidden self-center">
    <button data-open-hamburger-menu="true">
      <svg height="32" width="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path fill="black" class="heroicon-ui" d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"/>
      </svg>
    </button>

    <button data-close-hamburger-menu="true" class="hidden">
      <svg fill="black" height="32" id="close" viewBox="0 0 32 32" width="32" xmlns="http://www.w3.org/2000/svg">
        <path d="M4 8 L8 4 L16 12 L24 4 L28 8 L20 16 L28 24 L24 28 L16 20 L8 28 L4 24 L12 16 z"/>
      </svg>
    </button>
  </div>
</div>

<div class="hidden md:hidden fixed pin bg-white z-10 mt-32 pt-12" data-hamburger-menu="true">
  <ul class="list-reset tracking-wide flex flex-col items-center w-full">
    

    <li class="my-2">
      
        <a class="font-semibold text-xl text-grey no-underline uppercase" href='/articles/'>Articles</a>
      
    </li>
    

    <li class="my-2">
      
        <a class="font-semibold text-xl text-grey no-underline uppercase" href='/til/'>TIL</a>
      
    </li>
    

    <li class="my-2">
      
        <a class="font-semibold text-xl text-grey no-underline uppercase" href='/photography/'>Photography</a>
      
    </li>
    

    <li class="my-2">
      
        <a class="font-semibold text-xl text-grey no-underline uppercase" href='/reading/'>Reading list</a>
      
    </li>
    

    <li class="my-2">
      
        <a class="font-semibold text-xl text-grey no-underline uppercase" href='/subscribe'>Subscribe</a>
      
    </li>
    
  </ul>
</div>


      <div class="w-full flex justify-center text-lg mt-16 text-grey-darker font-light leading-normal">
        <div class="flex-col">
          <div class="max-w-full">
            

          </div>

          <div class="post max-w-full md:max-w-md">
            
            

            <div>
              <a class="no-underline uppercase text-sm" href="/articles"> ← articles </a>
            </div>

            <div class="mb-8">
              <h1>My experience with switching apps for personal knowledge management</h1>

              <div class="flex justify-between" data-nosnippet>
                
                  <div class="text-grey text-sm" data-js-time-ago>
                    December 13, 2020
                  </div>
                

                <div data-js-views-container class="hidden inline text-grey text-sm">
                  <span data-js-views>0</span> views
                </div>
              </div>

              <div class="flex my-2" data-nosnippet>
                
              </div>
            </div>

            <p>Personal knowledge management (PKM) is the best thing I discovered in 2019. I&#39;ve since tried a couple of different approaches and too many (six) apps. In this article, I would like to share everything I&#39;ve learned about it over that period.</p>

<blockquote>
<p>Investment in knowledge pays the best interest.</p>

<p>Benjamin Franklin</p>
</blockquote>

<h2>Why bother?</h2>

<p>Given that every PKM system requires a significant time investment, it&#39;s worth asking yourself what&#39;s the point. What&#39;s the benefit of spending all this time on writing notes? For me personally, it boils down to having a higher return of investment on reading itself.</p>

<p>I love reading and learning from the wins and mistakes of others since I can&#39;t live long enough to make them all by myself, in the words of Eleanor Roosevelt. I have noticed that I tend to forget ideas from the books by just reading and not taking notes. I&#39;ve fallen to the fallacy of &quot;transmissionism&quot;, as Andy Matuschak calls it in <a href="https://andymatuschak.org/books/">his great article about books</a>. The belief that by just reading a book, I&#39;m going to absorb the knowledge from it. In reality, I don&#39;t really learn much that way.</p>

<p>Taking notes fights this effect of forgetting ideas. Instead of just reading, your goal becomes a search for interesting ideas that you can feed into your system. As you feed more interesting ideas into your PKM system, it becomes more valuable. PKM enables network effects for ideas. Instead of observing the radioactive decay of ideas from the books you read, their value starts compounding. <sup>[<a href="#radioactive-decay">1</a>]</sup></p>

<p>I&#39;ve come to realize that reading is just one part of learning. The other part is writing. Or, as Sahil Livingia has said: &quot;Reading is the inhale, writing is the exhale.&quot;</p>

<h2>The benefits of PKM</h2>

<p>Although I&#39;ve tried using Building a Second Brain (BASB) as my PKM method, my current method is Zettelkasten (ZK). So, I&#39;ll try to explain its benefits.</p>

<p>Zettelkasten is easy and fun for me. It makes reading, writing, and thinking more fun.</p>

<p>Reading becomes fun since I&#39;m on the hunt for new ideas. Instead of just going through the book for bragging rights and signaling purposes, I&#39;m hunting for surprising. When I find it, I&#39;m happy since I can put it into my notes and improve all notes&#39; quality.</p>

<p>Writing becomes more fun since I do it in smaller increments. Instead of staring at a blank page when writing new essays, they write themselves from the bottom up. Every note is what Tiago Forte calls an &quot;intermediate packet&quot;. The essay gets composed out of smaller, reusable packets that each make sense on its own. Topics start to emerge. And so do the ideas for essays.</p>

<p>Thinking becomes more fun too. Making connections between notes and seeing contradictory notes triggers interesting questions. Instead of thinking just inside of your head, you get a system and environment that fosters that. As &quot;How To Take Smart Notes&quot; writes, storing permanent notes is a form of dialogue with your past notes. And this kind of dialogue encourages thinking more about the ideas that you encounter while reading.</p>

<p>Just writing things down in my own words improves my thinking. As Niklas Luhmann, the Zettelkasten method&#39;s inventor has said, &quot;It&#39;s not possible to think systematically without writing&quot;. By writing things down in your own words, you start realizing how much you understand (or don&#39;t understand) about the subject. You realize the holes in your arguments. Questions start arising. Questions that wouldn&#39;t otherwise be asked had you just done thinking inside of your head. Writing reveals questions and gaps in arguments.</p>

<h2>BASB in Notion</h2>

<p>My first encounter with PKM was learning about BASB from Maria Aldrey. She has used Notion to take notes and organize them into four categories in a system called PARA:
  - &quot;Projects&quot;, which have to have a deadline
  - &quot;Areas&quot;, which are your specific long-term areas of improvement
  - &quot;Resources&quot;, which contain categorized notes and highlights from articles and books
  - &quot;Archive&quot;, which contain archived projects, areas, and resources</p>

<p>Although I didn&#39;t take the official course from Tiago, I went through all of his articles about PARA. After adding many articles and book notes to it, I started categorizing them and going through the process of &quot;progressive summarization&quot;, one of the most important lessons from Tiago.</p>

<p>It consists of adding layers of highlights to articles and books. Normally, bolding enables two layers of importance for content. Bolded text is important, while unbolded is unimportant. </p>

<p>The PARA method adds some additional layers of importance:
  - unbolded text
  - bolded text
  - highlighted (colored) text
  - summary
  - remix (original creation)</p>

<p>Not every piece of content needs to go through all five steps, but the most interesting pieces will go through all of them. The most interesting step is the remix, in which you try to connect the ideas expressed here with other notes in your system.</p>

<p>I gave this system a go for a couple of months, but it didn&#39;t stick in the end. I was too tired from deciding how to categorize every note and where to put it. I ended up thinking about the organization more than about the content I&#39;m saving. It felt too heavy for my taste, and it wasn&#39;t a fun process. The distinction between &quot;Areas&quot; and &quot;Resources&quot; always confused me, and I never got used to it. My summarized notes, in the end, weren&#39;t connecting and ended up being isolated islands. I was unable to find relevant concepts with the search. So after a couple of months, I&#39;ve stopped doing it.</p>

<h2>No structure in Roam</h2>

<p>This brings us to Roam. After totally cooling down from BASB and Notion, I&#39;ve discovered Roam and marveled at the beauty of it. Instead of writing notes and categorizing them, I started connecting them. As I wrote in <a href="https://shime.sh/why-i-love-roam">an article</a> from that time, Roam has freed me from unnecessary compartmentalization and encouraged me to build networks of ideas, which is more like how my brain works. It&#39;s a network, not an archive.</p>

<p>However, I didn&#39;t follow any system for taking these notes. I&#39;ve later realized that not being systematic comes with a huge drawback. It all becomes a &quot;magical junkyard&quot; that is hard to navigate. I ended up with many notes and connections, but nothing in it ended up being useful. Each note was either empty, contained one idea, or hundreds of ideas. There was no way to differentiate them, so I ended up not knowing what&#39;s useful. Searching was also difficult since I didn&#39;t follow any method for naming my notes.</p>

<p>That&#39;s why I&#39;ve started to investigate other methods like BASB and found out about Zettelkasten.</p>

<h2>Zettelkasten in Roam</h2>

<p>I&#39;ve decided to add some structure after realizing that my Roam database is turning into &quot;the magical junkyard&quot;. And that&#39;s what Zettelkasten gave me. I&#39;ve started keeping atomic notes, or notes that consisted of one idea only, and started being more careful with the note titles.</p>

<p>I&#39;ve started thinking what the most useful title for each note is, considering my future searches. I&#39;ve realized that note titles are like APIs. But, only viscerally since I&#39;ve only later read <a href="https://notes.andymatuschak.org/Evergreen_note_titles_are_like_APIs">Andy Matuschak&#39;s notes on the subject</a>. I wasn&#39;t that good at naming my notes and started by using the <a href="https://www.swyx.io/two-words/">Two Words approach</a> that wasn&#39;t very useful for future searches.</p>

<p>Using Zettelkasten in Roam meant that I got to preserve the fun I get from taking notes in Roam in an unstructured way while still fighting the fear of building a castle of sand. As &quot;How to Take Smart Notes&quot; writes, &quot;a standardized work environment is less taxing for our motivation&quot; and &quot;having a system we can rely on makes us reduce decisions we have to make during a work session&quot;. This standardized work environment is provided by BASB too, but with Zettelkasten, it&#39;s not as heavy and hierarchical. There are fewer decisions that have to be made when taking notes. The network is built organically, bottom-up and not top-down.</p>

<p>However, after using Roam for some time, I got concerned about having my notes stored in a proprietary format, so I&#39;ve started experimenting with other apps. I am a software developer, and I spend most of the day in the terminal, manipulating text in Vim. The blog you&#39;re reading uses Jekyll, a static site generator that stores blog posts in Markdown.</p>

<p>I am a fan of Markdown since it&#39;s easy to read for humans in its raw form, and it&#39;s still very powerful with formatting. It&#39;s just text that doesn&#39;t need a special app to be read (unlike Roam). I would rather bet that 100 years from now, people will still be able to read Markdown than I would on people being able to read Roam notes at that time. Simply put, I wanted my Zettelkasten notes to survive a long period, and that&#39;s why I started experimenting with other apps.</p>

<h2>Switching to Zettlr</h2>

<p>My first experiment was switching to <a href="https://www.zettlr.com/">Zettlr</a>. The most promising thing that pulled me to try it out was that it was built specifically for Zettelkasten and uses Markdown under the hood. However, this experiment lasted very briefly. After realizing that I can&#39;t create new notes by just surrounding the term with brackets, I&#39;ve decided to quit.</p>

<p>Using Roam for a couple of months made me perceive this behavior as something very basic and essential. It&#39;s easy to forget that not every note-taking app supports creating new notes in such a low-friction way.</p>

<h2>Switching to Vim</h2>

<p>I loved reading <a href="https://superorganizers.substack.com/p/how-to-build-a-learning-machine">this article about building a Zettelkasten system directly in Vim, with help from bash</a>. Since I&#39;ve been using Vim for more than a decade, I am biased for using it for every context that I can. Or at least try.</p>

<p>After some tweaking and playing around with <a href="https://github.com/vimwiki/vimwiki">Vim Wiki</a> and <a href="https://github.com/junegunn/fzf.vim">fzf.vim</a>, I&#39;ve ended with a somewhat functional environment.</p>

<p><img src="/public/vim-pkm.png" alt=""></p>

<p>I loved how everything was just plain Markdown, enhanced with Wiki-style links a la Roam. Creating new notes was effortless and worked by just surrounding the terms, unlike Zettlr. I especially loved how easy it was to open multiple notes at once for a higher picture. The only limit on how many notes I can view simultaneously was imposed by the screen size.</p>

<p>However, backlinks were problematic and required hacks. I was not satisfied after installing <a href="https://github.com/andymatuschak/note-link-janitor">note link janitor</a> by Andy Matuschak, since it didn&#39;t come close to the power of backlinks in Roam. It was buggy, and often times the backlinks didn&#39;t provide enough context, but just the first line of the mention. Editing notes directly in backlinks, like in Roam, was not supported.</p>

<p>What also bugged me was the fact that all of this was stored only on my computer. I&#39;ve added an auto-command in Vim that created an encrypted backup in the background every time I&#39;ve changed something and uploaded it to the cloud. However, I still wanted to edit my notes from the phone from time to time. Some people create their knowledge base directly on Google Drive and Dropbox and then edit text files from their phones, but this didn&#39;t seem attractive.</p>

<p>I&#39;ve decided to try something else since this environment felt too crude for me, and I had a fear of missing out. The thought that I could probably make more connections and think better had I used something else was always in the back of my mind.</p>

<h2>Switching to Obsidian</h2>

<p>After being somewhat skeptical when first seeing it, since I couldn&#39;t find the name of the company behind it, I&#39;ve decided to give <a href="https://obsidian.md/">Obsidian</a> a go. I liked the fact that everything is stored locally and that it used Markdown. It felt similar to using Vim, but since it was specifically made to create and manage a &quot;second brain&quot;, it had some nice additional features.</p>

<p>One of the nicest was the support for backlinks out-of-the-box. However, the excitement with backlinks wore off pretty quickly since I was used to the more powerful version from Roam. They support customization with CSS, which allows some pretty fun stuff, like <a href="https://github.com/kmaasrud/awesome-obsidian#andy-matuschak-mode">Andy Matuschak mode</a>.</p>

<p>As with Vim, they support opening many notes simultaneously in the same window. This is perhaps the only thing regarding the user experience that is better than Roam. Although Roam offers the graph view for seeing connections between notes, I find it useful to look at the entire text from notes. It feels more like arranging physical notes on a table and then looking for connections.</p>

<p>The drawbacks of using Obsidian were similar to those of Vim. I couldn&#39;t read or edit anything on my phone, and I felt a lot of FOMO. That&#39;s why I&#39;ve yet again decided to switch.</p>

<h2>Switching to Bear</h2>

<p>I&#39;ve been using Bear for a long time, and I was happy with their UI and features. Still, I never considered using them for personal knowledge management. They also use Markdown for everything and store data locally in an SQLite database.</p>

<p>I love their emphasis on minimalism and how well-polished their mobile app is. The user experience on a computer, phone, and tablet is top-notch. There is no support for backlinks in Bear, although there&#39;s <a href="https://github.com/andymatuschak/bear-link-janitor">Andy Matuschak&#39;s hack</a> for this too. I didn&#39;t use it this time and wanted to see how far I can go without them.</p>

<p>I&#39;ve found that they are not super critical for Zettelkasten. I had to be more intentional with the links and decide what kind of connection I want to make between every pair of connected notes. I&#39;ve found that not every connection needs to be two-sided, like with backlinks. <a href="https://notes.andymatuschak.org/z68tVM68dEAuH4acs7HY6K76tTVzBdoBGKMZB">Using fine-grained associations</a> instead of just listing notes that have something in common with a particular note has proven to be pretty useful. The backlinks provide another kind of relationship between notes, an implicit one, useful for discovery but not critical. Intentional relationships that are built by direct links are much more important.</p>

<p>One thing that started bothering me after I&#39;ve created ~1500 notes in Bear is how slow it gets when renaming notes. Renaming a note that&#39;s referenced a lot freezes Bear for some reason. It becomes unresponsive for 30 seconds, which is very annoying.</p>

<p>The benefit of opening multiple notes at the same time available in Vim and Obsidian is not present in Bear. To do so in Bear, each note has to be opened in a new window, which feels clunky and frictional.</p>

<p>Although I&#39;ve been using some custom scripts for importing book highlights from Apple Books to Bear, which were useful to reference from my Zettelkasten, something was missing from my setup: the ability to save highlights from articles that I read online. Having all of the highlights in one place to connect, reference, and remix is a very powerful feature.</p>

<p>To try to work around this problem, I&#39;ve tried using Bear&#39;s browser plugin for storing entire articles in Bear, but the results have been unsatisfactory. It doesn&#39;t come close to the quality of specialized read later apps like Instapaper and Pocket. What made it unusable is not that it couldn&#39;t store an article, but that it stored incomplete articles. It made me lose trust in using Bear&#39;s browser plugin and on the lookout for better solutions.</p>

<p>This brings us to...</p>

<h2>Readwise, or why I&#39;m back in Roam</h2>

<p>Although it looked unpolished (at the time, they have since updated their design), Readwise was a very popular tool inside #roamcult, which is how I discovered it. It didn&#39;t take long to realize how useful it is. When connected with Instapaper, Kindle, and Apple Books, it really becomes one of the most useful tools in the PKM toolkit. By capturing highlights from absolutely everything I&#39;ve read, it becomes storage of the best of the best from my inputs. And then it resurfaces these best chunks to fight the forgetting curve. Marvelous.</p>

<p>As I was still using Bear at the time, I was frustrated that it didn&#39;t have an automatic connection to Bear. Understandably, since Bear currently doesn&#39;t have a web app or an API. However, I&#39;ve noticed that there is such a connection with Roam, which made me go back to it.</p>

<p>And now I&#39;m back at step one. I have both my Zettelkasten and all the things I&#39;ve highlighted in Roam, and I don&#39;t have to take action to make it happen. The only change I have to make is to read all the articles in Instapaper (I could use the browser extension for this, but I don&#39;t trust third-party plugins enough to share all my passwords with them).</p>

<h2>Thoughts on coming back to Roam after a long time</h2>

<p>Coming back to Roam after all of these switches has made me aware of other great features of Roam that are easy to get used to but which don&#39;t exist in other Markdown-based apps.</p>

<p>One of the most prominent ones is probably blocks and their transclusion abilities. Just as how everything is an object in Ruby, so everything is a block in Roam. This has proven to be very helpful when writing articles by following <a href="https://www.youtube.com/watch?v=RvWic15iXjk">Nat Eliason&#39;s approach</a>. This article was written following that approach, along with zooming in into the blocks that follow titles from the outline. Writing this article has been the most enjoyable experience with writing so far (which is why this is the longest article I&#39;ve written). This is somewhat surprising for me, as I didn&#39;t think that the app I am using could greatly impact my writing experience.</p>

<p>Another surprising thing with Roam is how much easier it made writing a weekly newsletter. It feels like Roam was made to synthesize the best of content, which is the same goal of my newsletter. It&#39;s very easy to either link to the next edition from wherever or just put the blank page of the next edition of the newsletter in the sidebar and go on the hunt for juicy blocks. As with writing, this has surprised me since I didn&#39;t expect the app to make such a difference.</p>

<p>A couple of other worthy mentions missing from all the other apps I&#39;ve tried are the sidebar and links in note titles. Sidebar enables exploration and makes transclusion easier, while links in note titles make linking even more effortless. With them, I can even create links from blank pages. I found it the most useful when linking to a concept that I&#39;ve picked from another person (e.g., &quot;How to think for yourself per [[Paul Graham]]&quot;).</p>

<p>Since coming back to Roam, I&#39;ve also made some changes with how I do Zettelkasten. I no longer follow <a href="https://www.youtube.com/watch?v=ljyo_WAJevQ">Shu Omi&#39;s approach</a> for taking notes. The biggest flaw with that approach is that I&#39;ve ended with many notes that express ideas from other authors in my own words and few ideas of my own. To fix that, I&#39;ve added another layer of abstraction on top of what he calls permanent notes in his video. I&#39;ll share more about that in a future article since this one is too long as it is.</p>

<p>As I&#39;ve discovered that Roam is a superior environment for writing, and therefore thinking, I&#39;m glad to sacrifice the longevity of my notes that I might have gotten with Markdown. After all, longevity is less important than the impact on the quality and enjoyment of thinking. Without enjoyment and a supportive environment, the notes will never reach the quality required to have them preserved in the first place.</p>

<hr>

<ol>
<li><a name="radioactive-decay"></a>
The idea about radioactive decay is stolen from my co-rafter Nick Ang and <a href="https://www.nickang.com/2020-07-05-personal-knowledge-management-system/">his essay on personal knowledge management</a>.</li>
</ol>


            <div class="flex items-center justify-between pt-8 pb-8 md:pb-0" data-nosnippet>
              <div class="flex items-center">
                <div class="kudo">
                </div>

                <div class="ml-2 font-bold text-black">
                  <span data-js-kudos-count>
                    0
                  </span>

                  kudos
                </div>
              </div>

              <a href="mailto:shime@hey.com?subject=My experience with switching apps for personal knowledge management">Reply via email</a>
            </div>

            
              <div class="mt-12 bg-grey-lightest p-8 text-grey-darkest border-t-4 border-grey-light">
                Join my newsletter and get articles that sometimes end up on the front page of Hacker News straight in your inbox.

                


<p class="mt-4 max-w-sm m-auto">
  <div class="mt-8">
    <form
       action="https://buttondown.email/api/emails/embed-subscribe/shime"
       method="post"
       target="popupwindow"
       onsubmit="window.open('https://buttondown.email/shime', 'popupwindow')"
       class="embeddable-buttondown-form"
       >
       <div class="flex max-w-sm m-auto">
         <input type="email" name="email" id="bd-email" class="bg-white appearance-none rounded rounded-r-none w-full py-2 px-4 text-grey-darker leading-tight focus:outline-none"  placeholder="you@domain.com">
         <input type="hidden" value="1" name="embed"></input>
         
         <input type="submit" value="Subscribe" class="cursor-pointer shadow bg-black hover:bg-grey-darkest focus:outline-none text-white font-bold py-2 px-4 rounded rounded-l-none"></input>
       </div>
       <div class="flex justify-center text-xs max-w-sm m-auto"><span>Unsubscribe anytime. By submitting your email, you agree to our <a href="/privacy">privacy policy</a>.</span></div>
     </form>
  </div>
</p>

              </div>
            
          </div>
        </div>
      </div>
    </div>

  <script>
  (function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
      module.exports = factory();
    else if(typeof define === 'function' && define.amd)
      define(factory);
    else if(typeof exports === 'object')
      exports["kudos"] = factory();
    else
      root["kudos"] = factory();
  })(this, function() {
    return /******/ (function(modules) { // webpackBootstrap
      /******/ 	// The module cache
      /******/ 	var installedModules = {};

      /******/ 	// The require function
      /******/ 	function __webpack_require__(moduleId) {

        /******/ 		// Check if module is in cache
        /******/ 		if(installedModules[moduleId])
          /******/ 			return installedModules[moduleId].exports;

        /******/ 		// Create a new module (and put it into the cache)
        /******/ 		var module = installedModules[moduleId] = {
          /******/ 			exports: {},
          /******/ 			id: moduleId,
          /******/ 			loaded: false
        /******/ 		};

        /******/ 		// Execute the module function
        /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

        /******/ 		// Flag the module as loaded
        /******/ 		module.loaded = true;

        /******/ 		// Return the exports of the module
        /******/ 		return module.exports;
      /******/ 	}


      /******/ 	// expose the modules object (__webpack_modules__)
      /******/ 	__webpack_require__.m = modules;

      /******/ 	// expose the module cache
      /******/ 	__webpack_require__.c = installedModules;

      /******/ 	// __webpack_public_path__
      /******/ 	__webpack_require__.p = "";

      /******/ 	// Load entry module and return exports
      /******/ 	return __webpack_require__(0);
    /******/ })
    /************************************************************************/
    /******/ ([
      /* 0 */
      /***/ function(module, exports, __webpack_require__) {

        __webpack_require__(1)
        var html = __webpack_require__(5)
        var bean = __webpack_require__(8)

        var datas = [];
        var donothing = function(evt) {
          evt.stop();
        };
        var start = function(evt) {
          evt.stop();
          var target = evt.currentTarget;
          var attr = Array.apply(null,target.attributes);
          var id = attr.filter(function(v) {
            return v.name=='data-id';
          }).shift().value;
          var d = datas[id];
          if(d.state) return;
          target.className = 'kudos-js-container hover';
          var done = function() {
            if(!d.state) {
              target.className = 'kudos-js-container yes';
              d.state = true;
              if(d.onkudo) {
                d.onkudo(function() {
                  // done
                });
              }
            }
          };
          d.tid = setTimeout(function() {
            done();
          },1200);
        };
        var cancel = function(evt) {
          evt.stop();
          var target = evt.currentTarget;
          var attr = Array.apply(null,target.attributes);
          var id = attr.filter(function(v) {
            return v.name=='data-id';
          }).shift().value;
          var d = datas[id];
          clearTimeout(d.tid);
          if(d.state) return;
          target.className = 'kudos-js-container';
        };
        var kudos = function(sel,data) {
          if(!data) data = {};
          data.id = datas.length;
          sel.innerHTML = html(data);
          datas.push(data);
          if('ontouchstart' in document.documentElement) {
            bean.on(sel.firstChild,'touchstart',start);
            bean.on(sel.firstChild,'touchend',cancel);
          } else {
            bean.on(sel.firstChild,'mouseover',start);
            bean.on(sel.firstChild,'mouseout',cancel);
          }
          bean.on(sel,'click touchstart touchend mouseover mouseout',donothing);
        };

        module.exports = kudos;


      /***/ },
      /* 1 */
      /***/ function(module, exports, __webpack_require__) {

        // style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(2);
if(typeof content === 'string') content = [[module.id, content, '']];
// add the styles to the DOM
var update = __webpack_require__(4)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
  // When the styles change, update the <style> tags
if(!content.locals) {
  module.hot.accept("!!./../node_modules/css-loader/index.js!./style.css", function() {
    var newContent = require("!!./../node_modules/css-loader/index.js!./style.css");
    if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
    update(newContent);
  });
}
// When the module is disposed, remove the <style> tags
module.hot.dispose(function() { update(); });
}

        /***/ },
        /* 2 */
        /***/ function(module, exports, __webpack_require__) {

        exports = module.exports = __webpack_require__(3)();
        // imports


        // module
        exports.push([module.id, ".kudos-js-container{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2248%22%20height%3D%2248%22%20viewBox%3D%22-311%20373%2048%2048%22%3E%3Cstyle%3E.st0%7Bfill%3Anone%3B%7D%3C%2Fstyle%3E%3Cpath%20d%3D%22M-287%20373c-13.3%200-24%2010.7-24%2024s10.7%2024%2024%2024%2024-10.7%2024-24-10.7-24-24-24zm0%2045c-11.6%200-21-9.4-21-21s9.4-21%2021-21%2021%209.4%2021%2021-9.4%2021-21%2021z%22%20id%3D%22Layer_1%22%2F%3E%3Cpath%20class%3D%22st0%22%20d%3D%22M-311%20373h48v48h-48z%22%20id%3D%22Layer_4%22%2F%3E%3C%2Fsvg%3E) center center no-repeat;user-select:none;touch-callout:none}.kudos-js-container,.kudos-js-container a{width:48px;height:48px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}@-webkit-keyframes animation{0%{-webkit-transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}1.35%{-webkit-transform:matrix3d(1.233,0,0,0,0,1.233,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.233,0,0,0,0,1.233,0,0,0,0,1,0,0,0,0,1)}2.7%{-webkit-transform:matrix3d(1.549,0,0,0,0,1.549,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.549,0,0,0,0,1.549,0,0,0,0,1,0,0,0,0,1)}4.05%{-webkit-transform:matrix3d(1.781,0,0,0,0,1.781,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.781,0,0,0,0,1.781,0,0,0,0,1,0,0,0,0,1)}5.36%{-webkit-transform:matrix3d(1.855,0,0,0,0,1.855,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.855,0,0,0,0,1.855,0,0,0,0,1,0,0,0,0,1)}6.86%{-webkit-transform:matrix3d(1.784,0,0,0,0,1.784,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.784,0,0,0,0,1.784,0,0,0,0,1,0,0,0,0,1)}8.31%{-webkit-transform:matrix3d(1.646,0,0,0,0,1.646,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.646,0,0,0,0,1.646,0,0,0,0,1,0,0,0,0,1)}9.81%{-webkit-transform:matrix3d(1.532,0,0,0,0,1.532,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.532,0,0,0,0,1.532,0,0,0,0,1,0,0,0,0,1)}11.26%{-webkit-transform:matrix3d(1.496,0,0,0,0,1.496,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.496,0,0,0,0,1.496,0,0,0,0,1,0,0,0,0,1)}14.21%{-webkit-transform:matrix3d(1.582,0,0,0,0,1.582,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.582,0,0,0,0,1.582,0,0,0,0,1,0,0,0,0,1)}17.17%{-webkit-transform:matrix3d(1.643,0,0,0,0,1.643,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.643,0,0,0,0,1.643,0,0,0,0,1,0,0,0,0,1)}23.02%{-webkit-transform:matrix3d(1.583,0,0,0,0,1.583,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.583,0,0,0,0,1.583,0,0,0,0,1,0,0,0,0,1)}28.93%{-webkit-transform:matrix3d(1.607,0,0,0,0,1.607,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.607,0,0,0,0,1.607,0,0,0,0,1,0,0,0,0,1)}34.78%{-webkit-transform:matrix3d(1.597,0,0,0,0,1.597,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.597,0,0,0,0,1.597,0,0,0,0,1,0,0,0,0,1)}40.69%{-webkit-transform:matrix3d(1.601,0,0,0,0,1.601,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.601,0,0,0,0,1.601,0,0,0,0,1,0,0,0,0,1)}46.6%,49.9%,50%{-webkit-transform:matrix3d(1.6,0,0,0,0,1.6,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.6,0,0,0,0,1.6,0,0,0,0,1,0,0,0,0,1)}53.15%{-webkit-transform:matrix3d(1.37,0,0,0,0,1.37,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.37,0,0,0,0,1.37,0,0,0,0,1,0,0,0,0,1)}56.26%{-webkit-transform:matrix3d(1.227,0,0,0,0,1.227,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.227,0,0,0,0,1.227,0,0,0,0,1,0,0,0,0,1)}59.41%{-webkit-transform:matrix3d(1.137,0,0,0,0,1.137,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.137,0,0,0,0,1.137,0,0,0,0,1,0,0,0,0,1)}62.51%{-webkit-transform:matrix3d(1.083,0,0,0,0,1.083,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.083,0,0,0,0,1.083,0,0,0,0,1,0,0,0,0,1)}68.77%{-webkit-transform:matrix3d(1.029,0,0,0,0,1.029,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.029,0,0,0,0,1.029,0,0,0,0,1,0,0,0,0,1)}75.03%{-webkit-transform:matrix3d(1.009,0,0,0,0,1.009,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.009,0,0,0,0,1.009,0,0,0,0,1,0,0,0,0,1)}87.54%{-webkit-transform:matrix3d(1.001,0,0,0,0,1.001,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.001,0,0,0,0,1.001,0,0,0,0,1,0,0,0,0,1)}100%{-webkit-transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}}@keyframes animation{0%{-webkit-transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}1.35%{-webkit-transform:matrix3d(1.233,0,0,0,0,1.233,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.233,0,0,0,0,1.233,0,0,0,0,1,0,0,0,0,1)}2.7%{-webkit-transform:matrix3d(1.549,0,0,0,0,1.549,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.549,0,0,0,0,1.549,0,0,0,0,1,0,0,0,0,1)}4.05%{-webkit-transform:matrix3d(1.781,0,0,0,0,1.781,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.781,0,0,0,0,1.781,0,0,0,0,1,0,0,0,0,1)}5.36%{-webkit-transform:matrix3d(1.855,0,0,0,0,1.855,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.855,0,0,0,0,1.855,0,0,0,0,1,0,0,0,0,1)}6.86%{-webkit-transform:matrix3d(1.784,0,0,0,0,1.784,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.784,0,0,0,0,1.784,0,0,0,0,1,0,0,0,0,1)}8.31%{-webkit-transform:matrix3d(1.646,0,0,0,0,1.646,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.646,0,0,0,0,1.646,0,0,0,0,1,0,0,0,0,1)}9.81%{-webkit-transform:matrix3d(1.532,0,0,0,0,1.532,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.532,0,0,0,0,1.532,0,0,0,0,1,0,0,0,0,1)}11.26%{-webkit-transform:matrix3d(1.496,0,0,0,0,1.496,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.496,0,0,0,0,1.496,0,0,0,0,1,0,0,0,0,1)}14.21%{-webkit-transform:matrix3d(1.582,0,0,0,0,1.582,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.582,0,0,0,0,1.582,0,0,0,0,1,0,0,0,0,1)}17.17%{-webkit-transform:matrix3d(1.643,0,0,0,0,1.643,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.643,0,0,0,0,1.643,0,0,0,0,1,0,0,0,0,1)}23.02%{-webkit-transform:matrix3d(1.583,0,0,0,0,1.583,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.583,0,0,0,0,1.583,0,0,0,0,1,0,0,0,0,1)}28.93%{-webkit-transform:matrix3d(1.607,0,0,0,0,1.607,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.607,0,0,0,0,1.607,0,0,0,0,1,0,0,0,0,1)}34.78%{-webkit-transform:matrix3d(1.597,0,0,0,0,1.597,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.597,0,0,0,0,1.597,0,0,0,0,1,0,0,0,0,1)}40.69%{-webkit-transform:matrix3d(1.601,0,0,0,0,1.601,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.601,0,0,0,0,1.601,0,0,0,0,1,0,0,0,0,1)}46.6%,49.9%,50%{-webkit-transform:matrix3d(1.6,0,0,0,0,1.6,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.6,0,0,0,0,1.6,0,0,0,0,1,0,0,0,0,1)}53.15%{-webkit-transform:matrix3d(1.37,0,0,0,0,1.37,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.37,0,0,0,0,1.37,0,0,0,0,1,0,0,0,0,1)}56.26%{-webkit-transform:matrix3d(1.227,0,0,0,0,1.227,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.227,0,0,0,0,1.227,0,0,0,0,1,0,0,0,0,1)}59.41%{-webkit-transform:matrix3d(1.137,0,0,0,0,1.137,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.137,0,0,0,0,1.137,0,0,0,0,1,0,0,0,0,1)}62.51%{-webkit-transform:matrix3d(1.083,0,0,0,0,1.083,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.083,0,0,0,0,1.083,0,0,0,0,1,0,0,0,0,1)}68.77%{-webkit-transform:matrix3d(1.029,0,0,0,0,1.029,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.029,0,0,0,0,1.029,0,0,0,0,1,0,0,0,0,1)}75.03%{-webkit-transform:matrix3d(1.009,0,0,0,0,1.009,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.009,0,0,0,0,1.009,0,0,0,0,1,0,0,0,0,1)}87.54%{-webkit-transform:matrix3d(1.001,0,0,0,0,1.001,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1.001,0,0,0,0,1.001,0,0,0,0,1,0,0,0,0,1)}100%{-webkit-transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}}.kudos-js-container a{display:block;background:url(data:image/svg+xml,%3Csvg%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2248%22%20height%3D%2248%22%20viewBox%3D%22-281%20373%2048%2048%22%3E%3Cstyle%3E.st0%7Bfill%3Anone%3B%7D%3C%2Fstyle%3E%3Ccircle%20id%3D%22Layer_3%22%20cx%3D%22-257%22%20cy%3D%22397%22%20r%3D%2224%22%2F%3E%3Cpath%20id%3D%22Layer_4%22%20class%3D%22st0%22%20d%3D%22M-281%20373h48v48h-48v-48z%22%2F%3E%3C%2Fsvg%3E) center center no-repeat;-webkit-transition:background-size 1.2s linear;transition:background-size 1.2s linear;background-size:25% 25%;user-select:none;touch-callout:none}.kudos-js-container a:hover,.kudos-js-container.hover a,.kudos-js-container.yes a,.kudos-js-container.yes a:hover{background-size:100% 100%}.kudos-js-container.yes a{-webkit-animation:animation 2000ms linear both;animation:animation 2000ms linear both;cursor:default;background-image:url(data:image/svg+xml,%3Csvg%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2248%22%20height%3D%2248%22%20viewBox%3D%22-281%20373%2048%2048%22%3E%3Cstyle%3E.st0%7Bfill%3Anone%3B%7D%3C%2Fstyle%3E%3Cpath%20d%3D%22M-257%20379c-9.9%200-18%208.1-18%2018s8.1%2018%2018%2018%2018-8.1%2018-18-8.1-18-18-18zm1.1%2024l-1.1%201-1.1-1c-3.9-3.5-6.4-5.8-6.4-8.6%200-2.3%201.8-4.1%204.1-4.1%201.3%200%202.6.6%203.4%201.6.8-1%202.1-1.6%203.4-1.6%202.3%200%204.1%201.8%204.1%204.1%200%202.8-2.5%205.1-6.4%208.6z%22%2F%3E%3Cpath%20class%3D%22st0%22%20d%3D%22M-281%20373h48v48h-48z%22%2F%3E%3C%2Fsvg%3E);-webkit-transition:none;transition:none}", ""]);

        // exports


      /***/ },
      /* 3 */
      /***/ function(module, exports) {

      /*
         MIT License http://www.opensource.org/licenses/mit-license.php
         Author Tobias Koppers @sokra
       */
        // css base code, injected by the css-loader
        module.exports = function() {
          var list = [];

          // return the list of modules as css string
          list.toString = function toString() {
            var result = [];
            for(var i = 0; i < this.length; i++) {
              var item = this[i];
              if(item[2]) {
                result.push("@media " + item[2] + "{" + item[1] + "}");
              } else {
                result.push(item[1]);
              }
            }
            return result.join("");
          };

          // import a list of modules into the list
          list.i = function(modules, mediaQuery) {
            if(typeof modules === "string")
            modules = [[null, modules, ""]];
            var alreadyImportedModules = {};
            for(var i = 0; i < this.length; i++) {
              var id = this[i][0];
              if(typeof id === "number")
              alreadyImportedModules[id] = true;
            }
            for(i = 0; i < modules.length; i++) {
              var item = modules[i];
              // skip already imported module
              // this implementation is not 100% perfect for weird media query combinations
              //  when a module is imported multiple times with different media queries.
              //  I hope this will never occur (Hey this way we have smaller bundles)
              if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                if(mediaQuery && !item[2]) {
                  item[2] = mediaQuery;
                } else if(mediaQuery) {
                  item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                }
                list.push(item);
              }
            }
          };
          return list;
        };


      /***/ },
      /* 4 */
      /***/ function(module, exports, __webpack_require__) {

      /*
         MIT License http://www.opensource.org/licenses/mit-license.php
         Author Tobias Koppers @sokra
       */
        var stylesInDom = {},
        memoize = function(fn) {
          var memo;
          return function () {
            if (typeof memo === "undefined") memo = fn.apply(this, arguments);
            return memo;
          };
        },
        isOldIE = memoize(function() {
          return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
        }),
      getHeadElement = memoize(function () {
        return document.head || document.getElementsByTagName("head")[0];
      }),
    singletonElement = null,
    singletonCounter = 0;

    module.exports = function(list, options) {
      if(false) {
        if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
      }

      options = options || {};
      // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
if (typeof options.singleton === "undefined") options.singleton = isOldIE();

var styles = listToStyles(list);
addStylesToDom(styles, options);

return function update(newList) {
  var mayRemove = [];
  for(var i = 0; i < styles.length; i++) {
    var item = styles[i];
    var domStyle = stylesInDom[item.id];
    domStyle.refs--;
    mayRemove.push(domStyle);
  }
  if(newList) {
    var newStyles = listToStyles(newList);
    addStylesToDom(newStyles, options);
  }
  for(var i = 0; i < mayRemove.length; i++) {
    var domStyle = mayRemove[i];
    if(domStyle.refs === 0) {
      for(var j = 0; j < domStyle.parts.length; j++)
      domStyle.parts[j]();
      delete stylesInDom[domStyle.id];
    }
  }
};
    }

    function addStylesToDom(styles, options) {
      for(var i = 0; i < styles.length; i++) {
        var item = styles[i];
        var domStyle = stylesInDom[item.id];
        if(domStyle) {
          domStyle.refs++;
          for(var j = 0; j < domStyle.parts.length; j++) {
            domStyle.parts[j](item.parts[j]);
          }
          for(; j < item.parts.length; j++) {
            domStyle.parts.push(addStyle(item.parts[j], options));
          }
        } else {
          var parts = [];
          for(var j = 0; j < item.parts.length; j++) {
            parts.push(addStyle(item.parts[j], options));
          }
          stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
        }
      }
    }

    function listToStyles(list) {
      var styles = [];
      var newStyles = {};
      for(var i = 0; i < list.length; i++) {
        var item = list[i];
        var id = item[0];
        var css = item[1];
        var media = item[2];
        var sourceMap = item[3];
        var part = {css: css, media: media, sourceMap: sourceMap};
        if(!newStyles[id])
        styles.push(newStyles[id] = {id: id, parts: [part]});
        else
        newStyles[id].parts.push(part);
      }
      return styles;
    }

    function createStyleElement() {
      var styleElement = document.createElement("style");
      var head = getHeadElement();
      styleElement.type = "text/css";
      head.appendChild(styleElement);
      return styleElement;
    }

    function createLinkElement() {
      var linkElement = document.createElement("link");
      var head = getHeadElement();
      linkElement.rel = "stylesheet";
      head.appendChild(linkElement);
      return linkElement;
    }

    function addStyle(obj, options) {
      var styleElement, update, remove;

      if (options.singleton) {
        var styleIndex = singletonCounter++;
        styleElement = singletonElement || (singletonElement = createStyleElement());
        update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
        remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
      } else if(obj.sourceMap &&
        typeof URL === "function" &&
      typeof URL.createObjectURL === "function" &&
      typeof URL.revokeObjectURL === "function" &&
      typeof Blob === "function" &&
      typeof btoa === "function") {
        styleElement = createLinkElement();
        update = updateLink.bind(null, styleElement);
        remove = function() {
          styleElement.parentNode.removeChild(styleElement);
          if(styleElement.href)
          URL.revokeObjectURL(styleElement.href);
        };
      } else {
        styleElement = createStyleElement();
        update = applyToTag.bind(null, styleElement);
        remove = function() {
          styleElement.parentNode.removeChild(styleElement);
        };
      }

      update(obj);

      return function updateStyle(newObj) {
        if(newObj) {
          if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
          return;
          update(obj = newObj);
        } else {
          remove();
        }
      };
    }

    var replaceText = (function () {
      var textStore = [];

      return function (index, replacement) {
        textStore[index] = replacement;
        return textStore.filter(Boolean).join('\n');
      };
    })();

  function applyToSingletonTag(styleElement, index, remove, obj) {
    var css = remove ? "" : obj.css;

    if (styleElement.styleSheet) {
      styleElement.styleSheet.cssText = replaceText(index, css);
    } else {
      var cssNode = document.createTextNode(css);
      var childNodes = styleElement.childNodes;
      if (childNodes[index]) styleElement.removeChild(childNodes[index]);
      if (childNodes.length) {
        styleElement.insertBefore(cssNode, childNodes[index]);
      } else {
        styleElement.appendChild(cssNode);
      }
    }
  }

  function applyToTag(styleElement, obj) {
    var css = obj.css;
    var media = obj.media;
    var sourceMap = obj.sourceMap;

    if(media) {
      styleElement.setAttribute("media", media)
    }

    if(styleElement.styleSheet) {
      styleElement.styleSheet.cssText = css;
    } else {
      while(styleElement.firstChild) {
        styleElement.removeChild(styleElement.firstChild);
      }
      styleElement.appendChild(document.createTextNode(css));
    }
  }

  function updateLink(linkElement, obj) {
    var css = obj.css;
    var media = obj.media;
    var sourceMap = obj.sourceMap;

    if(sourceMap) {
      // http://stackoverflow.com/a/26603875
      css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
    }

    var blob = new Blob([css], { type: "text/css" });

    var oldSrc = linkElement.href;

    linkElement.href = URL.createObjectURL(blob);

    if(oldSrc)
    URL.revokeObjectURL(oldSrc);
  }


  /***/ },
  /* 5 */
  /***/ function(module, exports, __webpack_require__) {

  var jade = __webpack_require__(6);

  module.exports = function template(locals) {
    var buf = [];
    var jade_mixins = {};
    var jade_interp;
    ;var locals_for_with = (locals || {});(function (id, state) {
      buf.push("<div" + (jade.attr("data-id", "" + (id) + "", true, false)) + (jade.cls(['kudos-js-container',"" + (state?'yes':'') + ""], [null,true])) + "><a href=\"#\"></a></div>");}.call(this,"id" in locals_for_with?locals_for_with.id:typeof id!=="undefined"?id:undefined,"state" in locals_for_with?locals_for_with.state:typeof state!=="undefined"?state:undefined));;return buf.join("");
  }

  /***/ },
  /* 6 */
  /***/ function(module, exports, __webpack_require__) {

  'use strict';

/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

  exports.merge = function merge(a, b) {
    if (arguments.length === 1) {
      var attrs = a[0];
      for (var i = 1; i < a.length; i++) {
        attrs = merge(attrs, a[i]);
      }
      return attrs;
    }
    var ac = a['class'];
    var bc = b['class'];

    if (ac || bc) {
      ac = ac || [];
      bc = bc || [];
      if (!Array.isArray(ac)) ac = [ac];
      if (!Array.isArray(bc)) bc = [bc];
      a['class'] = ac.concat(bc).filter(nulls);
    }

    for (var key in b) {
      if (key != 'class') {
        a[key] = b[key];
      }
    }

    return a;
  };

/**
 * Filter null `val`s.
 *
 * @param {*} val
 * @return {Boolean}
 * @api private
 */

  function nulls(val) {
    return val != null && val !== '';
  }

  /**
   * join array as classes.
   *
   * @param {*} val
   * @return {String}
   */
  exports.joinClasses = joinClasses;
  function joinClasses(val) {
    return (Array.isArray(val) ? val.map(joinClasses) :
      (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
    [val]).filter(nulls).join(' ');
  }

  /**
   * Render the given classes.
   *
   * @param {Array} classes
   * @param {Array.<Boolean>} escaped
   * @return {String}
   */
  exports.cls = function cls(classes, escaped) {
    var buf = [];
    for (var i = 0; i < classes.length; i++) {
      if (escaped && escaped[i]) {
        buf.push(exports.escape(joinClasses([classes[i]])));
      } else {
        buf.push(joinClasses(classes[i]));
      }
    }
    var text = joinClasses(buf);
    if (text.length) {
      return ' class="' + text + '"';
    } else {
      return '';
    }
  };


  exports.style = function (val) {
    if (val && typeof val === 'object') {
      return Object.keys(val).map(function (style) {
        return style + ':' + val[style];
      }).join(';');
    } else {
      return val;
    }
  };
/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */
  exports.attr = function attr(key, val, escaped, terse) {
    if (key === 'style') {
      val = exports.style(val);
    }
    if ('boolean' == typeof val || null == val) {
      if (val) {
        return ' ' + (terse ? key : key + '="' + key + '"');
      } else {
        return '';
      }
    } else if (0 == key.indexOf('data') && 'string' != typeof val) {
      if (JSON.stringify(val).indexOf('&') !== -1) {
        console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
          'will be escaped to `&amp;`');
      };
      if (val && typeof val.toISOString === 'function') {
        console.warn('Jade will eliminate the double quotes around dates in ' +
          'ISO form after 2.0.0');
      }
      return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
    } else if (escaped) {
      if (val && typeof val.toISOString === 'function') {
        console.warn('Jade will stringify dates in ISO form after 2.0.0');
      }
      return ' ' + key + '="' + exports.escape(val) + '"';
    } else {
      if (val && typeof val.toISOString === 'function') {
        console.warn('Jade will stringify dates in ISO form after 2.0.0');
      }
      return ' ' + key + '="' + val + '"';
    }
  };

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 */
  exports.attrs = function attrs(obj, terse){
    var buf = [];

    var keys = Object.keys(obj);

    if (keys.length) {
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i]
        , val = obj[key];

        if ('class' == key) {
          if (val = joinClasses(val)) {
            buf.push(' ' + key + '="' + val + '"');
          }
        } else {
          buf.push(exports.attr(key, val, false, terse));
        }
      }
    }

    return buf.join('');
  };

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

  var jade_encode_html_rules = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;'
  };
  var jade_match_html = /[&<>"]/g;

  function jade_encode_char(c) {
    return jade_encode_html_rules[c] || c;
  }

  exports.escape = jade_escape;
  function jade_escape(html){
    var result = String(html).replace(jade_match_html, jade_encode_char);
    if (result === '' + html) return html;
    else return result;
  };

/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

  exports.rethrow = function rethrow(err, filename, lineno, str){
    if (!(err instanceof Error)) throw err;
    if ((typeof window != 'undefined' || !filename) && !str) {
      err.message += ' on line ' + lineno;
      throw err;
    }
    try {
      str = str || __webpack_require__(7).readFileSync(filename, 'utf8')
    } catch (ex) {
      rethrow(err, null, lineno)
    }
    var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

    // Error context
    var context = lines.slice(start, end).map(function(line, i){
      var curr = i + start + 1;
      return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
    }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
  + '\n' + context + '\n\n' + err.message;
  throw err;
  };

  exports.DebugItem = function DebugItem(lineno, filename) {
    this.lineno = lineno;
    this.filename = filename;
  }


  /***/ },
  /* 7 */
  /***/ function(module, exports) {

  /* (ignored) */

  /***/ },
  /* 8 */
  /***/ function(module, exports, __webpack_require__) {

  var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
                                                                     * Bean - copyright (c) Jacob Thornton 2011-2012
                                                                     * https://github.com/fat/bean
                                                                     * MIT license
                                                                     */
  (function (name, context, definition) {
    if (typeof module != 'undefined' && module.exports) module.exports = definition()
    else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    else context[name] = definition()
  })('bean', this, function (name, context) {
    name    = name    || 'bean'
    context = context || this

    var win            = window
    , old            = context[name]
    , namespaceRegex = /[^\.]*(?=\..*)\.|.*/
  , nameRegex      = /\..*/
  , addEvent       = 'addEventListener'
  , removeEvent    = 'removeEventListener'
  , doc            = document || {}
  , root           = doc.documentElement || {}
  , W3C_MODEL      = root[addEvent]
  , eventSupport   = W3C_MODEL ? addEvent : 'attachEvent'
  , ONE            = {} // singleton for quick matching making add() do one()

  , slice          = Array.prototype.slice
  , str2arr        = function (s, d) { return s.split(d || ' ') }
  , isString       = function (o) { return typeof o == 'string' }
  , isFunction     = function (o) { return typeof o == 'function' }

  // events that we consider to be 'native', anything not in this list will
  // be treated as a custom event
  , standardNativeEvents =
  'click dblclick mouseup mousedown contextmenu '                  + // mouse buttons
  'mousewheel mousemultiwheel DOMMouseScroll '                     + // mouse wheel
  'mouseover mouseout mousemove selectstart selectend '            + // mouse movement
  'keydown keypress keyup '                                        + // keyboard
  'orientationchange '                                             + // mobile
  'focus blur change reset select submit '                         + // form elements
  'load unload beforeunload resize move DOMContentLoaded '         + // window
  'readystatechange message '                                      + // window
  'error abort scroll '                                              // misc
  // element.fireEvent('onXYZ'... is not forgiving if we try to fire an event
    // that doesn't actually exist, so make sure we only do these on newer browsers
    , w3cNativeEvents =
    'show '                                                          + // mouse buttons
    'input invalid '                                                 + // form elements
    'touchstart touchmove touchend touchcancel '                     + // touch
    'gesturestart gesturechange gestureend '                         + // gesture
    'textinput '                                                     + // TextEvent
    'readystatechange pageshow pagehide popstate '                   + // window
    'hashchange offline online '                                     + // window
    'afterprint beforeprint '                                        + // printing
    'dragstart dragenter dragover dragleave drag drop dragend '      + // dnd
    'loadstart progress suspend emptied stalled loadmetadata '       + // media
    'loadeddata canplay canplaythrough playing waiting seeking '     + // media
    'seeked ended durationchange timeupdate play pause ratechange '  + // media
    'volumechange cuechange '                                        + // media
    'checking noupdate downloading cached updateready obsolete '       // appcache

    // convert to a hash for quick lookups
    , nativeEvents = (function (hash, events, i) {
      for (i = 0; i < events.length; i++) events[i] && (hash[events[i]] = 1)
      return hash
    }({}, str2arr(standardNativeEvents + (W3C_MODEL ? w3cNativeEvents : ''))))

  // custom events are events that we *fake*, they are not provided natively but
  // we can use native events to generate them
  , customEvents = (function () {
    var isAncestor = 'compareDocumentPosition' in root
    ? function (element, container) {
      return container.compareDocumentPosition && (container.compareDocumentPosition(element) & 16) === 16
    }
    : 'contains' in root
    ? function (element, container) {
      container = container.nodeType === 9 || container === window ? root : container
      return container !== element && container.contains(element)
    }
    : function (element, container) {
      while (element = element.parentNode) if (element === container) return 1
      return 0
    }
    , check = function (event) {
      var related = event.relatedTarget
      return !related
      ? related == null
      : (related !== this && related.prefix !== 'xul' && !/document/.test(this.toString())
        && !isAncestor(related, this))
    }

    return {
      mouseenter: { base: 'mouseover', condition: check }
      , mouseleave: { base: 'mouseout', condition: check }
      , mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }
    }
  }())

// we provide a consistent Event object across browsers by taking the actual DOM
// event object and generating a new one from its properties.
, Event = (function () {
  // a whitelist of properties (for different event types) tells us what to check for and copy
  var commonProps  = str2arr('altKey attrChange attrName bubbles cancelable ctrlKey currentTarget ' +
    'detail eventPhase getModifierState isTrusted metaKey relatedNode relatedTarget shiftKey '  +
    'srcElement target timeStamp type view which propertyName')
  , mouseProps   = commonProps.concat(str2arr('button buttons clientX clientY dataTransfer '      +
    'fromElement offsetX offsetY pageX pageY screenX screenY toElement'))
  , mouseWheelProps = mouseProps.concat(str2arr('wheelDelta wheelDeltaX wheelDeltaY wheelDeltaZ ' +
    'axis')) // 'axis' is FF specific
  , keyProps     = commonProps.concat(str2arr('char charCode key keyCode keyIdentifier '          +
    'keyLocation location'))
  , textProps    = commonProps.concat(str2arr('data'))
  , touchProps   = commonProps.concat(str2arr('touches targetTouches changedTouches scale rotation'))
  , messageProps = commonProps.concat(str2arr('data origin source'))
  , stateProps   = commonProps.concat(str2arr('state'))
  , overOutRegex = /over|out/
  // some event types need special handling and some need special properties, do that all here
  , typeFixers   = [
  { // key events
    reg: /key/i
      , fix: function (event, newEvent) {
        newEvent.keyCode = event.keyCode || event.which
        return keyProps
      }
  }
  , { // mouse events
    reg: /click|mouse(?!(.*wheel|scroll))|menu|drag|drop/i
      , fix: function (event, newEvent, type) {
        newEvent.rightClick = event.which === 3 || event.button === 2
        newEvent.pos = { x: 0, y: 0 }
        if (event.pageX || event.pageY) {
          newEvent.clientX = event.pageX
          newEvent.clientY = event.pageY
        } else if (event.clientX || event.clientY) {
          newEvent.clientX = event.clientX + doc.body.scrollLeft + root.scrollLeft
          newEvent.clientY = event.clientY + doc.body.scrollTop + root.scrollTop
        }
        if (overOutRegex.test(type)) {
          newEvent.relatedTarget = event.relatedTarget
          || event[(type == 'mouseover' ? 'from' : 'to') + 'Element']
        }
        return mouseProps
      }
  }
  , { // mouse wheel events
    reg: /mouse.*(wheel|scroll)/i
      , fix: function () { return mouseWheelProps }
  }
  , { // TextEvent
    reg: /^text/i
      , fix: function () { return textProps }
  }
  , { // touch and gesture events
    reg: /^touch|^gesture/i
      , fix: function () { return touchProps }
  }
  , { // message events
    reg: /^message$/i
      , fix: function () { return messageProps }
  }
  , { // popstate events
    reg: /^popstate$/i
      , fix: function () { return stateProps }
  }
  , { // everything else
    reg: /.*/
  , fix: function () { return commonProps }
  }
  ]
  , typeFixerMap = {} // used to map event types to fixer functions (above), a basic cache mechanism

  , Event = function (event, element, isNative) {
    if (!arguments.length) return
    event = event || ((element.ownerDocument || element.document || element).parentWindow || win).event
    this.originalEvent = event
    this.isNative       = isNative
    this.isBean         = true

    if (!event) return

    var type   = event.type
    , target = event.target || event.srcElement
    , i, l, p, props, fixer

    this.target = target && target.nodeType === 3 ? target.parentNode : target

    if (isNative) { // we only need basic augmentation on custom events, the rest expensive & pointless
      fixer = typeFixerMap[type]
      if (!fixer) { // haven't encountered this event type before, map a fixer function for it
        for (i = 0, l = typeFixers.length; i < l; i++) {
          if (typeFixers[i].reg.test(type)) { // guaranteed to match at least one, last is .*
            typeFixerMap[type] = fixer = typeFixers[i].fix
            break
          }
        }
      }

      props = fixer(event, this, type)
      for (i = props.length; i--;) {
        if (!((p = props[i]) in this) && p in event) this[p] = event[p]
      }
    }
  }

  // preventDefault() and stopPropagation() are a consistent interface to those functions
  // on the DOM, stop() is an alias for both of them together
  Event.prototype.preventDefault = function () {
    if (this.originalEvent.preventDefault) this.originalEvent.preventDefault()
    else this.originalEvent.returnValue = false
  }
  Event.prototype.stopPropagation = function () {
    if (this.originalEvent.stopPropagation) this.originalEvent.stopPropagation()
    else this.originalEvent.cancelBubble = true
  }
  Event.prototype.stop = function () {
    this.preventDefault()
    this.stopPropagation()
    this.stopped = true
  }
  // stopImmediatePropagation() has to be handled internally because we manage the event list for
  // each element
  // note that originalElement may be a Bean#Event object in some situations
  Event.prototype.stopImmediatePropagation = function () {
    if (this.originalEvent.stopImmediatePropagation) this.originalEvent.stopImmediatePropagation()
    this.isImmediatePropagationStopped = function () { return true }
  }
  Event.prototype.isImmediatePropagationStopped = function () {
    return this.originalEvent.isImmediatePropagationStopped && this.originalEvent.isImmediatePropagationStopped()
  }
  Event.prototype.clone = function (currentTarget) {
    //TODO: this is ripe for optimisation, new events are *expensive*
    // improving this will speed up delegated events
    var ne = new Event(this, this.element, this.isNative)
    ne.currentTarget = currentTarget
    return ne
  }

  return Event
}())

        // if we're in old IE we can't do onpropertychange on doc or win so we use doc.documentElement for both
        , targetElement = function (element, isNative) {
          return !W3C_MODEL && !isNative && (element === doc || element === win) ? root : element
        }

        /**
         * Bean maintains an internal registry for event listeners. We don't touch elements, objects
         * or functions to identify them, instead we store everything in the registry.
         * Each event listener has a RegEntry object, we have one 'registry' for the whole instance.
         */
        , RegEntry = (function () {
          // each handler is wrapped so we can handle delegation and custom events
          var wrappedHandler = function (element, fn, condition, args) {
            var call = function (event, eargs) {
              return fn.apply(element, args ? slice.call(eargs, event ? 0 : 1).concat(args) : eargs)
            }
            , findTarget = function (event, eventElement) {
              return fn.__beanDel ? fn.__beanDel.ft(event.target, element) : eventElement
            }
            , handler = condition
            ? function (event) {
              var target = findTarget(event, this) // deleated event
              if (condition.apply(target, arguments)) {
                if (event) event.currentTarget = target
                return call(event, arguments)
              }
            }
            : function (event) {
              if (fn.__beanDel) event = event.clone(findTarget(event)) // delegated event, fix the fix
              return call(event, arguments)
            }
            handler.__beanDel = fn.__beanDel
            return handler
          }

          , RegEntry = function (element, type, handler, original, namespaces, args, root) {
            var customType     = customEvents[type]
            , isNative

            if (type == 'unload') {
              // self clean-up
              handler = once(removeListener, element, type, handler, original)
            }

            if (customType) {
              if (customType.condition) {
                handler = wrappedHandler(element, handler, customType.condition, args)
              }
              type = customType.base || type
            }

            this.isNative      = isNative = nativeEvents[type] && !!element[eventSupport]
            this.customType    = !W3C_MODEL && !isNative && type
            this.element       = element
            this.type          = type
            this.original      = original
            this.namespaces    = namespaces
            this.eventType     = W3C_MODEL || isNative ? type : 'propertychange'
            this.target        = targetElement(element, isNative)
            this[eventSupport] = !!this.target[eventSupport]
            this.root          = root
            this.handler       = wrappedHandler(element, handler, null, args)
          }

          // given a list of namespaces, is our entry in any of them?
          RegEntry.prototype.inNamespaces = function (checkNamespaces) {
            var i, j, c = 0
            if (!checkNamespaces) return true
            if (!this.namespaces) return false
            for (i = checkNamespaces.length; i--;) {
              for (j = this.namespaces.length; j--;) {
                if (checkNamespaces[i] == this.namespaces[j]) c++
              }
            }
            return checkNamespaces.length === c
          }

          // match by element, original fn (opt), handler fn (opt)
          RegEntry.prototype.matches = function (checkElement, checkOriginal, checkHandler) {
            return this.element === checkElement &&
              (!checkOriginal || this.original === checkOriginal) &&
            (!checkHandler || this.handler === checkHandler)
          }

          return RegEntry
        }())

      , registry = (function () {
        // our map stores arrays by event type, just because it's better than storing
        // everything in a single array.
        // uses '$' as a prefix for the keys for safety and 'r' as a special prefix for
        // rootListeners so we can look them up fast
        var map = {}

        // generic functional search of our registry for matching listeners,
        // `fn` returns false to break out of the loop
        , forAll = function (element, type, original, handler, root, fn) {
          var pfx = root ? 'r' : '$'
          if (!type || type == '*') {
            // search the whole registry
            for (var t in map) {
              if (t.charAt(0) == pfx) {
                forAll(element, t.substr(1), original, handler, root, fn)
              }
            }
          } else {
            var i = 0, l, list = map[pfx + type], all = element == '*'
            if (!list) return
            for (l = list.length; i < l; i++) {
              if ((all || list[i].matches(element, original, handler)) && !fn(list[i], list, i, type)) return
            }
          }
        }

        , has = function (element, type, original, root) {
          // we're not using forAll here simply because it's a bit slower and this
          // needs to be fast
          var i, list = map[(root ? 'r' : '$') + type]
          if (list) {
            for (i = list.length; i--;) {
              if (!list[i].root && list[i].matches(element, original, null)) return true
            }
          }
          return false
        }

        , get = function (element, type, original, root) {
          var entries = []
          forAll(element, type, original, null, root, function (entry) {
            return entries.push(entry)
          })
        return entries
        }

        , put = function (entry) {
          var has = !entry.root && !this.has(entry.element, entry.type, null, false)
          , key = (entry.root ? 'r' : '$') + entry.type
          ;(map[key] || (map[key] = [])).push(entry)
          return has
        }

        , del = function (entry) {
          forAll(entry.element, entry.type, null, entry.handler, entry.root, function (entry, list, i) {
            list.splice(i, 1)
            entry.removed = true
            if (list.length === 0) delete map[(entry.root ? 'r' : '$') + entry.type]
            return false
          })
        }

        // dump all entries, used for onunload
        , entries = function () {
          var t, entries = []
          for (t in map) {
            if (t.charAt(0) == '$') entries = entries.concat(map[t])
          }
          return entries
        }

        return { has: has, get: get, put: put, del: del, entries: entries }
      }())

    // we need a selector engine for delegated events, use querySelectorAll if it exists
    // but for older browsers we need Qwery, Sizzle or similar
    , selectorEngine
    , setSelectorEngine = function (e) {
      if (!arguments.length) {
        selectorEngine = doc.querySelectorAll
        ? function (s, r) {
          return r.querySelectorAll(s)
        }
        : function () {
          throw new Error('Bean: No selector engine installed') // eeek
        }
      } else {
        selectorEngine = e
      }
    }

    // we attach this listener to each DOM event that we need to listen to, only once
    // per event type per DOM element
    , rootListener = function (event, type) {
      if (!W3C_MODEL && type && event && event.propertyName != '_on' + type) return

      var listeners = registry.get(this, type || event.type, null, false)
      , l = listeners.length
      , i = 0

      event = new Event(event, this, true)
      if (type) event.type = type

      // iterate through all handlers registered for this type, calling them unless they have
      // been removed by a previous handler or stopImmediatePropagation() has been called
      for (; i < l && !event.isImmediatePropagationStopped(); i++) {
        if (!listeners[i].removed) listeners[i].handler.call(this, event)
      }
    }

    // add and remove listeners to DOM elements
    , listener = W3C_MODEL
    ? function (element, type, add) {
      // new browsers
      element[add ? addEvent : removeEvent](type, rootListener, false)
    }
    : function (element, type, add, custom) {
      // IE8 and below, use attachEvent/detachEvent and we have to piggy-back propertychange events
      // to simulate event bubbling etc.
      var entry
      if (add) {
        registry.put(entry = new RegEntry(
          element
          , custom || type
          , function (event) { // handler
            rootListener.call(element, event, custom)
          }
          , rootListener
          , null
          , null
          , true // is root
          ))
        if (custom && element['_on' + custom] == null) element['_on' + custom] = 0
        entry.target.attachEvent('on' + entry.eventType, entry.handler)
      } else {
        entry = registry.get(element, custom || type, rootListener, true)[0]
        if (entry) {
          entry.target.detachEvent('on' + entry.eventType, entry.handler)
          registry.del(entry)
        }
      }
    }

    , once = function (rm, element, type, fn, originalFn) {
      // wrap the handler in a handler that does a remove as well
      return function () {
        fn.apply(this, arguments)
        rm(element, type, originalFn)
      }
    }

    , removeListener = function (element, orgType, handler, namespaces) {
      var type     = orgType && orgType.replace(nameRegex, '')
      , handlers = registry.get(element, type, null, false)
      , removed  = {}
      , i, l

      for (i = 0, l = handlers.length; i < l; i++) {
        if ((!handler || handlers[i].original === handler) && handlers[i].inNamespaces(namespaces)) {
          // TODO: this is problematic, we have a registry.get() and registry.del() that
          // both do registry searches so we waste cycles doing this. Needs to be rolled into
          // a single registry.forAll(fn) that removes while finding, but the catch is that
          // we'll be splicing the arrays that we're iterating over. Needs extra tests to
          // make sure we don't screw it up. @rvagg
          registry.del(handlers[i])
          if (!removed[handlers[i].eventType] && handlers[i][eventSupport])
          removed[handlers[i].eventType] = { t: handlers[i].eventType, c: handlers[i].type }
        }
      }
      // check each type/element for removed listeners and remove the rootListener where it's no longer needed
      for (i in removed) {
        if (!registry.has(element, removed[i].t, null, false)) {
          // last listener of this type, remove the rootListener
          listener(element, removed[i].t, false, removed[i].c)
        }
      }
    }

    // set up a delegate helper using the given selector, wrap the handler function
    , delegate = function (selector, fn) {
      //TODO: findTarget (therefore $) is called twice, once for match and once for
      // setting e.currentTarget, fix this so it's only needed once
      var findTarget = function (target, root) {
        var i, array = isString(selector) ? selectorEngine(selector, root) : selector
        for (; target && target !== root; target = target.parentNode) {
          for (i = array.length; i--;) {
            if (array[i] === target) return target
          }
        }
      }
      , handler = function (e) {
        var match = findTarget(e.target, this)
        if (match) fn.apply(match, arguments)
      }

      // __beanDel isn't pleasant but it's a private function, not exposed outside of Bean
      handler.__beanDel = {
        ft       : findTarget // attach it here for customEvents to use too
        , selector : selector
      }
      return handler
    }

    , fireListener = W3C_MODEL ? function (isNative, type, element) {
      // modern browsers, do a proper dispatchEvent()
      var evt = doc.createEvent(isNative ? 'HTMLEvents' : 'UIEvents')
      evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, win, 1)
      element.dispatchEvent(evt)
    } : function (isNative, type, element) {
      // old browser use onpropertychange, just increment a custom property to trigger the event
      element = targetElement(element, isNative)
      isNative ? element.fireEvent('on' + type, doc.createEventObject()) : element['_on' + type]++
    }

    /**
     * Public API: off(), on(), add(), (remove()), one(), fire(), clone()
     */

    /**
     * off(element[, eventType(s)[, handler ]])
     */
    , off = function (element, typeSpec, fn) {
      var isTypeStr = isString(typeSpec)
      , k, type, namespaces, i

      if (isTypeStr && typeSpec.indexOf(' ') > 0) {
        // off(el, 't1 t2 t3', fn) or off(el, 't1 t2 t3')
        typeSpec = str2arr(typeSpec)
        for (i = typeSpec.length; i--;)
        off(element, typeSpec[i], fn)
        return element
      }

      type = isTypeStr && typeSpec.replace(nameRegex, '')
      if (type && customEvents[type]) type = customEvents[type].base

      if (!typeSpec || isTypeStr) {
        // off(el) or off(el, t1.ns) or off(el, .ns) or off(el, .ns1.ns2.ns3)
        if (namespaces = isTypeStr && typeSpec.replace(namespaceRegex, '')) namespaces = str2arr(namespaces, '.')
        removeListener(element, type, fn, namespaces)
      } else if (isFunction(typeSpec)) {
        // off(el, fn)
        removeListener(element, null, typeSpec)
      } else {
        // off(el, { t1: fn1, t2, fn2 })
        for (k in typeSpec) {
          if (typeSpec.hasOwnProperty(k)) off(element, k, typeSpec[k])
        }
      }

      return element
    }

    /**
     * on(element, eventType(s)[, selector], handler[, args ])
     */
    , on = function(element, events, selector, fn) {
      var originalFn, type, types, i, args, entry, first

      //TODO: the undefined check means you can't pass an 'args' argument, fix this perhaps?
      if (selector === undefined && typeof events == 'object') {
        //TODO: this can't handle delegated events
        for (type in events) {
          if (events.hasOwnProperty(type)) {
            on.call(this, element, type, events[type])
          }
        }
        return
      }

      if (!isFunction(selector)) {
        // delegated event
        originalFn = fn
        args       = slice.call(arguments, 4)
        fn         = delegate(selector, originalFn, selectorEngine)
      } else {
        args       = slice.call(arguments, 3)
        fn         = originalFn = selector
      }

      types = str2arr(events)

      // special case for one(), wrap in a self-removing handler
      if (this === ONE) {
        fn = once(off, element, events, fn, originalFn)
      }

      for (i = types.length; i--;) {
        // add new handler to the registry and check if it's the first for this element/type
        first = registry.put(entry = new RegEntry(
          element
          , types[i].replace(nameRegex, '') // event type
          , fn
          , originalFn
          , str2arr(types[i].replace(namespaceRegex, ''), '.') // namespaces
          , args
          , false // not root
          ))
        if (entry[eventSupport] && first) {
          // first event of this type on this element, add root listener
          listener(element, entry.eventType, true, entry.customType)
        }
      }

      return element
    }

    /**
     * add(element[, selector], eventType(s), handler[, args ])
     *
     * Deprecated: kept (for now) for backward-compatibility
     */
    , add = function (element, events, fn, delfn) {
      return on.apply(
        null
        , !isString(fn)
        ? slice.call(arguments)
        : [ element, fn, events, delfn ].concat(arguments.length > 3 ? slice.call(arguments, 5) : [])
        )
    }

    /**
     * one(element, eventType(s)[, selector], handler[, args ])
     */
    , one = function () {
      return on.apply(ONE, arguments)
    }

    /**
     * fire(element, eventType(s)[, args ])
     *
     * The optional 'args' argument must be an array, if no 'args' argument is provided
     * then we can use the browser's DOM event system, otherwise we trigger handlers manually
     */
    , fire = function (element, type, args) {
      var types = str2arr(type)
      , i, j, l, names, handlers

      for (i = types.length; i--;) {
        type = types[i].replace(nameRegex, '')
        if (names = types[i].replace(namespaceRegex, '')) names = str2arr(names, '.')
        if (!names && !args && element[eventSupport]) {
          fireListener(nativeEvents[type], type, element)
        } else {
          // non-native event, either because of a namespace, arguments or a non DOM element
          // iterate over all listeners and manually 'fire'
          handlers = registry.get(element, type, null, false)
          args = [false].concat(args)
          for (j = 0, l = handlers.length; j < l; j++) {
               if (handlers[j].inNamespaces(names)) {
               handlers[j].handler.apply(element, args)
               }
               }
               }
               }
               return element
               }

               /**
               * clone(dstElement, srcElement[, eventType ])
               *
               * TODO: perhaps for consistency we should allow the same flexibility in type specifiers?
               */
               , clone = function (element, from, type) {
               var handlers = registry.get(from, type, null, false)
               , l = handlers.length
               , i = 0
               , args, beanDel

               for (; i < l; i++) {
               if (handlers[i].original) {
               args = [ element, handlers[i].type ]
               if (beanDel = handlers[i].handler.__beanDel) args.push(beanDel.selector)
               args.push(handlers[i].original)
               on.apply(null, args)
               }
               }
               return element
               }

               , bean = {
               'on'                : on
               , 'add'               : add
               , 'one'               : one
               , 'off'               : off
               , 'remove'            : off
               , 'clone'             : clone
               , 'fire'              : fire
               , 'Event'             : Event
               , 'setSelectorEngine' : setSelectorEngine
               , 'noConflict'        : function () {
               context[name] = old
               return this
               }
               }

               // for IE, clean up on unload to avoid leaks
               if (win.attachEvent) {
               var cleanup = function () {
               var i, entries = registry.entries()
               for (i in entries) {
               if (entries[i].type && entries[i].type !== 'unload') off(entries[i].element, entries[i].type)
               }
               win.detachEvent('onunload', cleanup)
               win.CollectGarbage && win.CollectGarbage()
               }
               win.attachEvent('onunload', cleanup)
               }

               // initialize selector engine to internal default (qSA or throw Error)
               setSelectorEngine()

               return bean
               });


               /***/ }
               /******/ ])
               });
               ;
               </script>

  <script>
  var menu = document.querySelectorAll('[data-hamburger-menu]')[0]
  var openMenu = document.querySelectorAll('[data-open-hamburger-menu]')[0]
  var closeMenu = document.querySelectorAll('[data-close-hamburger-menu]')[0]
  var body = document.body

  openMenu.onclick = toggleMenu.bind(this, true);
  closeMenu.onclick = toggleMenu.bind(this, false);

  function toggleMenu(show) {
    toggleElements([openMenu], !show);
    toggleElements([menu, closeMenu], show);
    toggleScrolling(body, show);
  }

  function toggleElements(elements, show) {
    elements.forEach(function(element) {
      if (show) {
        element.classList.remove("hidden")
        element.classList.add("block");
      } else {
        element.classList.remove("block")
        element.classList.add("hidden");
      }
    })
  }

  function toggleScrolling(element, scrollDisabled) {
    var classes = ["scrolling-auto", "overflow-hidden", "fixed", "pin-x"];
    if (scrollDisabled) {
      classes.forEach(function(klass){
        element.classList.add(klass);
      })
    } else {
      classes.forEach(function(klass){
        element.classList.remove(klass);
      })
    }
  }

  var anchors = new AnchorJS();
  anchors.options = {
    placement: 'left'
  }
  anchors.add()

  var timeAgoElement = document.querySelector("[data-js-time-ago]")
  var ta = timeago();
  var url = window.location.pathname

  if (timeAgoElement && timeAgoElement.innerHTML.match(/\w/)) {
    var ago = ta.ago(timeAgoElement.innerHTML + " 12:00:00", true);
    var span = document.createElement('span');

    span.innerHTML = "(" + ago + " ago)";
    timeAgoElement.appendChild(span);
  }

  var updateKudos = function(count) {
    document.querySelector("[data-js-kudos-count]").innerHTML = count;
  }

  if (window.location.hostname !== "localhost") {
    fetch("https://backend.shime.sh/analytics", {
      method: "POST",
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ "url": url })
    }).then(function(response) {
      return response.json()
    }).then(function(body) {
      if (window.location.search.match(/analytics/)) {
        var container = document.querySelector("[data-js-views-container]");
        var views = document.querySelector("[data-js-views]");
        views.innerHTML = body.pageviews;

        container.classList.remove("hidden");
      }

      if (typeof(kudos) !== "undefined") {
        updateKudos(body.kudos);

        var k = kudos(document.querySelector('.kudo'),{
          // set initial state(true:already kudoed.)
          state: localStorage.getItem(url),
          // on kudo
          onkudo:function(next) {
            localStorage.setItem(url, true);

            fetch("https://backend.shime.sh/kudos", {
              method: "POST",
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ "url": window.location.pathname })
            }).then(function(response) {
              return response.json()
            }).then(function(body){
              updateKudos(body.kudos);
              next();
            });
          }
        });
      }
    });
  }
</script>

</html>
